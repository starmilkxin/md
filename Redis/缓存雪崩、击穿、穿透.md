# 缓存雪崩

场景:

1. 大量缓存数据在同一时间过期（失效） => 大量用户请求从Redis转向数据库 => 数据库压力过大宕机 => 系统瘫痪
2. Redis 故障宕机 => 大量用户请求从Redis转向数据库 => 数据库压力过大宕机 => 系统瘫痪

场景一解决方法:

1. 均匀设置过期时间: 避免大量缓存同时过期，缓存的过期时间设置加上一个随机数。 
2. 限制请求数据库(上锁): 当请求的数据不在Redis中，需要去访问数据库时，对一定范围内的缓存数据上互斥锁，保证同一时间内只有少数请求来构建缓存。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。
3. 限制请求数据库(消息队列): 当请求的数据不在Redis中，通过消息队列发送一条消息通知后台线程更新缓存，后台线程收到消息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。消息队列可以有效访问数据库的频率。
4. 缓存预热：业务刚上线时，首先将热点数据与假数据进行缓存。

场景二解决方法:

1. 服务熔断与服务限流，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。
2. 通过主从节点的方式构建 Redis 缓存高可靠集群。 如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。

# 缓存击穿

场景:

1. 个别热点数据过期了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库被高并发的请求冲垮。

解决方法:

1. 属于缓存雪崩的子集，采用 限制请求数据库(上锁)、限制请求数据库(消息队列)、缓存预热。

# 缓存穿透

场景:

1. 当用户访问的数据，既不在缓存中，也不在数据库中，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是缓存穿透的问题。

解决方法:

1. 非法请求的限制: 对于请求参数非法的请求，直接返回错误。
2. 缓存空值或者默认值: 发生缓存穿透后，针对查询的数据，在缓存中设置一个空值或者默认值，后续请求从缓存中读取到空值或者默认值。
3. 布隆过滤器: 布隆过滤器判断数据是否存在于数据库中。布隆过滤器判断 数据不存在 => 数据一定不存在。布隆过滤器判断 数据存在 => 数据可能存在，也可能不存在。