# 缓存的CRUD
首先我们来想想缓存CRUD的时机。<br/>
一开始当我们想要获取数据时，首先希望能直接去缓存中获取，如果缓存未命中，则会从数据库中获取数据，然后再将其插入缓存中的，这便是C。<br/>
每次数据的请求都会先查缓存，企图从缓存中获取，这便是R。<br/>
当数据库中的A数据发生了更新或者是删除，注意，此时为了保证数据的一致性，所以缓存中如果也存有A数据，那么它也需要进行改动，这个时候问题就来了，我们对缓存中的A数据是采用更新还是删除操作呢？<br/>
一般的想法会是，将缓存中的A数据和数据库中的A数据一样进行更新不就行了吗，但其实这是有问题的。缓存一般用来存放热点数据，也就是说，只有当用户想要获取该数据时才会将其存入缓存。如果采用更新操作的话，就会使得可能无人访问的数据频繁更新导致其一直存储在缓存中，使得缓存的利用率低下。因此我们对缓存中的数据采用的是删除操作。<br/>

# 缓存与数据库的操作顺序
由上文我们知道，缓存的C是发生在缓存Miss的情况下的，而缓存的D则是发生在数据库数据删除或更新的情况下的。<br/>
第一种情况下的缓存与数据库的操作顺序是固定的，当缓存Miss后，必须要先查数据库，得到数据后才能将其插入缓存。<br/>
第二种情况下就复杂了，当我们有数据有更新(删除可以理解为特殊的更新)时，到底是先将缓存中的数据进行删除，然后再更新数据库呢，还是先更新数据库之后再删除缓存的数据呢？<br/>
其实这并没有一个统一的答案，不过我更倾向于先更新数据库之后再删除缓存的数据。为什么呢？我们分别来讨论。

## 异常问题
首先我们来看看，当发生异常时，两个方案会出现的问题<br/>
**先删除缓存，再更新数据库**
+ 当删除缓存成功后，更新数据库失败时，那么此时用户无法从缓存中获取数据，只能从数据库中获取未更新的旧数据，并且又会将其存储到缓存中，最重要的是，就算这时数据库中的数据更新完毕，但是缓存中的数据依旧是旧数据。无法实现数据的最终一致性。

**先更新数据库，再删除缓存**
+ 当更新数据库成功后，但是缓存删除失败后，那么此时缓存中依旧存储着旧数据，所以用户此时访问会得到旧数据，但是，当缓存成功删除后，那么用户就会因为缓存Miss然后再访问数据库中新数据并且将新数据存储在缓存中。可以实现数据的最终一致性。

***

题外话，当发生异常后，无论是更新数据库或者是删除缓存操作，我们都可以使用binlog回放来进行重试，亦或是，将操作一开始就放入消息队列中。
+ 消息队列保证了可靠性，所以就算任务失败后，服务器宕机了，也不会丢失之前未消费的消息。(重启项目也不担心)
+ 消息队列保证了消息的成功投递，下游从队列拉取消息，成功消费后才会删除消息，否则还会继续投递消息给消费者。(符合我们重试的场景)

虽然说消息队列中的写队列同样也可能会失败，但是同时发生的概率是非常小的，所以是一个合适的解决途径。

## 并发性问题
接下来我们再来看看高并发情况下，两个方案会出现的问题。<br/>
**先删除缓存，再更新数据库**
1. 线程 A 要更新 X = 2（原值 X = 1）
2. 线程 A 先删除缓存
3. 线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）
4. 线程 A 将新值写入数据库（X = 2）
5. 线程 B 将旧值写入缓存（X = 1）

最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。<br/>
可见，先删除缓存，后更新数据库，当发生「读+写」并发时，存在数据不一致的情况

**先更新数据库，再删除缓存**
1. 缓存中 X 不存在（数据库 X = 1）
2. 线程 A 读取数据库，得到旧值（X = 1）
3. 线程 B 更新数据库（X = 2)
4. 线程 B 删除缓存
5. 线程 A 将旧值写入缓存（X = 1）

最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），也发生不一致。但其实这种情况发生的概率非常的低。<br/>
因为它必须满足 3 个条件：
1. 缓存刚好已失效
2. 读请求 + 写请求并发
3. 更新数据库 + 删除缓存的时间（步骤 3-4），要比读数据库 + 写缓存时间短（步骤 2 和 5）

仔细想一下，条件 3 发生的概率其实是非常低的。<br/>
因为写数据库一般会先「加锁」，所以写数据库，通常是要比读数据库的时间更长的。<br/>
这么来看，「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的。<br/>

## 主从库复制延迟问题
Redis作为高可用集群，有着主从复制、哨兵模式等功能。但也就是因为主库向从库复制时存在着延迟<br/>
在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」其实也会导致不一致：
1. 线程 A 更新主库 X = 2（原值 X = 1）
2. 线程 A 删除缓存
3. 线程 B 查询缓存，没有命中，查询「从库」得到旧值（从库 X = 1）
4. 从库「同步」完成（主从库 X = 2）
5. 线程 B 将「旧值」写入缓存（X = 1）

这种情况和之前所提到的并发性问题一样，都是在数据库更新前获取到了旧值，在其更新完毕并删除缓存后才将旧值存储到了缓存中。<br/>
解决的方法就是业界公认的缓存**延迟双删策略**。顾名思义，就是在删除缓存后，等待一段时间后再一次地删除，目的就是为了将旧值删除。
+ 对于并发性问题，延迟时间要大于线程 B 读取数据库 + 写入缓存的时间。
+ 对于主从库复制延迟问题，延迟时间要大于「主从复制」的延迟时间。

这种方式可以进一步地增强了一致性，但是还是无法做到强一致性。

## 强一致性
要想做到强一致性，那么就得要在更新数据库和删除缓存这一过程中，防止任何其他线程进行任何操作，这就需要加锁。Redis分布式锁便可以做到。<br/>
谈到Redis分布式锁，那么我们就要注意设置锁的过期时间、使用UUID来防止锁过期导致的锁误删、使用LUA脚本保证删除的原子性。<br/>
强一致性必然会带来其并发性能的降低。性能和一致性不能同时满足，为了性能考虑，通常会采用「最终一致性」的方案。<br/>
<br/>
