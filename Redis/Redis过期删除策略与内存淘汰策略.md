# 过期删除策略

过期时间设置

- expire <key\> <n\>：设置 key 在 n 秒后过期，比如 expire key 100 表示设置 key 在 100 秒后过期；
- pexpire <key\> <n\>：设置 key 在 n 毫秒后过期，比如 pexpire key2 100000 表示设置 key2 在 100000 毫秒（100 秒）后过期。
- expireat <key\> <n\>：设置 key 在某个时间戳（精确到秒）之后过期，比如 expireat key3 1655654400 表示 key3 在时间戳 1655654400 后过期（精确到秒）；
- pexpireat <key> <n>：设置 key 在某个时间戳（精确到毫秒）之后过期，比如 pexpireat key4 1655654400000 表示 key4 在时间戳 1655654400000 后过期（精确到毫秒）

设置字符串时同时设置过期时间

- set <key\> <value\> ex <n\> ：设置键值对的时候，同时指定过期时间（精确到秒）；
- set <key\> <value\> px <n\> ：设置键值对的时候，同时指定过期时间（精确到毫秒）；
- setex <key\> <n\> <valule\> ：设置键值对的时候，同时指定过期时间（精确到秒）。

查看某个 key 剩余的存活时间

- TTL <key\>

取消 key 的过期时间

- PERSIST <key\>

过期删除策略

- 定时删除: 在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作。 
- 惰性删除: 不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。
- 定期删除: 周期性轮询redis服务所有的db库中的时效性数据。

Redis 采用 惰性删除+定期删除

- 定时删除对内存友好，对 CPU 不友好。
- 惰性删除对 CPU 友好，对内存不友好。
- 定期删除为折中方案。

Redis 惰性删除流程图:

![惰性删除](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/惰性删除.png)

Redis 定期删除流程图:

![定期删除](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/定期删除.png)

# 内存淘汰策略

当 Redis 的运行内存已经超过 Redis 设置的最大内存之后，则会使用内存淘汰策略删除符合条件的 key，以此来保障 Redis 高效的运行。

在配置文件 redis.conf 中，可以通过参数 maxmemory <bytes> 来设定最大运行内存，只有在 Redis 的运行内存达到了我们设置的最大运行内存，才会触发内存淘汰策略。

不同位数的操作系统，maxmemory 的默认值是不同的：

- 在 64 位操作系统中，maxmemory 的默认值是 0，表示没有内存大小限制，那么不管用户存放多少数据到 Redis 中，Redis 也不会对可用内存进行检查，直到 Redis 实例因内存不足而崩溃也无作为。
- 在 32 位操作系统中，maxmemory 的默认值是 3G，因为 32 位的机器最大只支持 4GB 的内存，而系统本身就需要一定的内存资源来支持运行，所以 32 位操作系统限制最大 3 GB 的可用内存是非常合理的，这样可以避免因为内存不足而导致 Redis 实例崩溃。

Redis 内存淘汰策略

- 不进行数据淘汰的策略
  - noeviction（Redis3.0之后，默认的内存淘汰策略）: 它表示当运行内存超过最大设置内存时，不淘汰任何数据，而是不再提供服务，直接返回错误。
- 进行数据淘汰的策略
  - 在设置了过期时间的数据中进行淘汰:
    - volatile-random：随机淘汰设置了过期时间的任意键值；
    - volatile-ttl：优先淘汰更早过期的键值。
    - volatile-lru（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；
    - volatile-lfu（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；
  - 在所有数据范围内进行淘汰:
    - allkeys-random：随机淘汰任意键值;
    - allkeys-lru：淘汰整个键值中最久未使用的键值；
    - allkeys-lfu（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。

