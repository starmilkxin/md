# Redis数据结构

Redis3.0 与 Redis最新版本 数据类型与数据结构的关系

![Redis数据结构](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/Redis数据结构.png)

Redis 键值对数据库的全景图

![Redis键值对数据库的全景图](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/Redis键值对数据库的全景图.png)

## SDS

Redis 用 C 语言实现，封装了一个名为简单动态字符串（simple dynamic string，SDS） 的数据结构来表示字符串，也就是 Redis 的 String 数据类型的底层数据结构是 SDS 代替 C 语言的 char* 字符数组。

C 语言字符串的缺陷

- 获取字符串长度的时间复杂度为 O（N）。C 语言获取字符串长度的函数 strlen，就是通过字符数组中的每一个字符，并进行计数，等遇到字符为 “\0” 后，就会停止遍历，然后返回已经统计到的字符个数，即为字符串长度。
- 字符串的结尾是以 “\0” 字符标识，字符串里面不能包含有 “\0” 字符，因此不能保存二进制数据。
- 字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止。

SDS 设计

- len，记录了字符串长度。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。
- alloc，分配给字符数组的空间长度。这样在修改字符串的时候，可以通过 alloc - len 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS  的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。
- flags，用来表示不同类型的 SDS。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。
- buf[]，字符数组，用来保存实际数据。不仅可以保存字符串，也可以保存二进制数据。

SDS 优势

- O（1）复杂度获取字符串长度。通过 len 成员变量。
- 二进制安全。因为 SDS 不需要用 “\0” 字符来标识字符串结尾了，而是有个专门的 len 成员变量来记录长度，所以可存储包含 “\0” 的数据。但是 SDS 为了兼容部分 C 语言标准库的函数， SDS 字符串结尾还是会加上 “\0” 字符。因此，SDS 的 API 都是以处理二进制的方式来处理 SDS 存放在 buf[] 里的数据，程序不会对其中的数据做任何限制，数据写入的时候时什么样的，它被读取时就是什么样的。 通过使用二进制安全的 SDS，而不是 C 字符串，使得 Redis 不仅可以保存文本数据，也可以保存任意格式的二进制数据。
- 不会发生缓冲区溢出。Redis 的 SDS 结构里引入了 alloc 和 len 成员变量，这样 SDS API 通过 alloc - len 计算，可以算出剩余可用的空间大小，这样在对字符串做修改操作的时候，就可以由程序内部判断缓冲区大小是否足够用。而且，当判断出缓冲区大小不够用时，Redis 会自动将扩大 SDS 的空间大小（小于 1MB 翻倍扩容，大于 1MB 按 1MB 扩容），以满足修改所需的大小。
- 节省内存空间。SDS 结构中有个 flags 成员变量，表示的是 SDS 类型。 Redos 一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。 这 5 种类型的主要区别就在于，它们数据结构中的 len 和 alloc 成员变量的数据类型不同。

## 链表

list 结构为链表提供了链表头指针 head、链表尾节点 tail、链表节点数量 len、以及可以自定义实现的 dup、free、match 函数。

listNdoe 包含 prev 和 next 指针，value 值。

Redis 链表优点:

- list 结构因为提供了表头指针 head 和表尾节点 tail，所以获取链表的表头节点和表尾节点的时间复杂度只需O(1)
- list 结构因为提供了链表节点数量 len，所以获取链表中的节点数量的时间复杂度只需O(1)
- listNode 链表节使用 void* 指针保存节点值，并且可以通过 list 结构的 dup、free、match 函数指针为节点设置该节点类型特定的函数，因此链表节点可以保存各种不同类型的值
- listNode 链表节点的结构里带有 prev 和 next 指针，获取某个节点的前置节点或后置节点的时间复杂度只需O(1)，而且这两个指针都可以指向 NULL，所以链表是无环链表

Redis 链表缺点:

- 链表每个节点之间的内存都是不连续的，意味着无法很好利用 CPU 缓存。
- 链表节点的内存开销较大。

## 压缩列表 ziplist

「压缩列表」作为底层数据结构的实现，它的优势是节省内存空间，并且是内存紧凑型的数据结构。占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。

压缩列表缺点:

- 不能保存过多的元素，否则查询效率就会降低。
- 新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。

因此 Redis 对象（List 对象、Hash 对象、Zset 对象）包含的元素数量较少，或者元素值不大的情况才会使用压缩列表作为底层数据结构。

压缩列表字段 (zlbytes + zltail + zllen + entry1 + entry2 ... + zlend):

- zlbytes，记录整个压缩列表占用对内存字节数
- zltail，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量
- zllen，记录压缩列表包含的节点数量
- zlend，标记压缩列表的结束点，固定值 0xFF（十进制255）

如果要查找第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，只能逐个查找，复杂度就是 O(N) ，因此压缩列表不适合保存过多的元素。

压缩列表节点 entry 包含三部分内容：

- prevlen，记录了「前一个节点」的长度。
- encoding，记录了当前节点实际数据的类型以及长度。
- data，记录了当前节点的实际数据。

prevlen 和 encoding 会根据数据的大小和类型来进行不同的空间大小分配，以此来达到节省内存。

prevlen 属性的空间大小跟前一个节点长度值有关:

- 如果前一个节点的长度小于 254 字节，那么 prevlen 属性需要用 1 字节的空间来保存这个长度值。
- 如果前一个节点的长度大于等于 254 字节，那么 prevlen 属性需要用 5 字节的空间来保存这个长度值。

encoding 属性的空间大小跟数据是字符串还是整数，以及字符串的长度有关:

- 如果当前节点的数据是整数，则 encoding 会使用 1 字节的空间进行编码。
- 如果当前节点的数据是字符串，根据字符串的长度大小，encoding 会使用 1 字节/2字节/5字节的空间进行编码。

连锁更新

当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降。

quicklist（Redis 3.2 引入） 和 listpack（Redis 5.0 引入），一方面尽可能地保持压缩列表节省内存的优势，另一方面解决压缩列表的「连锁更新」的问题。

## 哈希表

哈希冲突

Redis 采用了「链式哈希」的方法来解决哈希冲突。

rehash

之所以定义了 2 个哈希表，是因为进行 rehash 的时候，需要用上 2 个哈希表了。

![Redis键值对数据库的全景图](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/Redis键值对数据库的全景图.png)

随着数据逐步增多，触发了 rehash 操作，这个过程分为三步:

- 给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍。
- 将「哈希表 1 」的数据迁移到「哈希表 2」 中。
- 迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备。

渐进式 rehash

为了避免 rehash 在数据迁移过程中，因拷贝数据的耗时，影响 Redis 性能的情况，所以 Redis 采用了渐进式 rehash。

渐进式 rehash 步骤:

- 给「哈希表 2」 分配空间；
- 在 rehash 进行期间，每次哈希表元素进行 删除、查找或者更新操作 ，都会在这两个哈希表进行。 增加操作 只在哈希表2上进行。
- 在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」上。
- 除了根据键值对的操作来进行数据迁移，Redis本身还会有一个定时任务在执行rehash，如果没有键值对操作时，这个定时任务会周期性地搬移一些数据到哈希表2中，这样可以缩短整个rehash的过程。

rehash 触发条件

负载因子 = 哈希表已保存节点数量 / 哈希表大小

- 当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。
- 当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。

## 整数集合 intset

当Set对象可以同时满足以下两个条件时，则使用 intset 编码:

1. Set对象保存的所有元素都是整数值。
2. Set对象保存的元素数量不超过 512 个(默认值，配置参数set-max-intset-entries可以修改)。

```c++
typedef struct intset {
    //编码方式
    uint32_t encoding;
    //集合包含的元素数量
    uint32_t length;
    //保存元素的数组
    int8_t contents[];
} intset;
```

> 如果 encoding 属性值为 INTSET_ENC_INT16，那么 contents 就是一个 int16_t 类型的数组，数组中每一个元素的类型都是 int16_t。不同类型的 contents 数组，意味着数组的大小也会不同。

整数集合的升级操作（不支持降级操作）

整数集合会有一个升级规则，就是当我们将一个新元素加入到整数集合里面，如果新元素的类型（int32_t）比整数集合现有所有元素的类型（int16_t）都要长时，整数集合需要先进行升级，也就是按新元素的类型（int32_t）扩展 contents 数组的空间大小，然后才能将新元素加入到整数集合里。

如果一直向整数集合添加 int16_t 类型的元素，那么整数集合的底层实现就一直是用 int16_t 类型的数组，只有在我们要将 int32_t 类型或 int64_t 类型的元素添加到集合时，才会对数组进行升级操作，以此节省内存资源。

## 跳表 SkipList

Zset 对象是唯一一个同时使用了两个数据结构来实现的 Redis 对象，这两个数据结构一个是跳表，一个是哈希表。这样的好处是既能进行高效的范围查询，也能进行高效单点查询。(但是我们讨论的时候，都会说跳表是 Zset 对象的底层数据结构，而不会提及哈希表，是因为 struct zset 中的哈希表只是用于以常数复杂度获取元素权重，大部分操作都是跳表实现的。)

![跳表](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/跳表.png)

## quicklist

在 Redis 3.0 之前，List 对象的底层数据结构是双向链表或者压缩列表。然后在  Redis 3.2 的时候，List 对象的底层改由 quicklist 数据结构实现。

其实 quicklist 就是「双向链表 + 压缩列表」组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表。

通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。

![quicklist](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/quicklist.png)

在向 quicklist 添加一个元素的时候，不会像普通的链表那样，直接新建一个链表节点。而是会检查插入位置的压缩列表是否能容纳该元素，如果能容纳就直接保存到 quicklistNode 结构里的压缩列表，如果不能容纳，才会新建一个新的 quicklistNode 结构。

## listpack

![listpack](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/listpack.png)

listpack 节点:

- encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码。
- data，实际存放的数据。
- len，encoding+data的总长度。

listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题。