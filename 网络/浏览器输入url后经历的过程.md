# 浏览器输入url后发生了什么

![url过程](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/url过程.jpg)

![OSI七层模型](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/OSI七层模型.gif)

![osi](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/osi.jpeg)

## 解析url

浏览器确定 Web 服务器和文件名

根据这些信息来生成 HTTP 请求消息

## DNS查询

1. 客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。
2. 浏览器查看浏览器缓存-->系统缓存-->查找本地host文件-->本地DNS服务器缓存，如果存在则返回，没有，则发送请求给根域名服务器。
3. 根域名服务器存在则返回，没有，则会告诉本地DNS服务器对应顶级域名服务器的位置，本地DNS服务器再去请求顶级域名服务器。
4. 顶级域名服务器存在则返回，没有，则会告诉本地DNS服务器对应权威域名服务器的位置，本地DNS服务器再去请求权威域名服务器。
5. 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。
6. 本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。

## HTTP报文 -> 增加 TCP 头部 -> 增加 IP 头部 -> 增加 MAC 头部

协议栈->TCP->IP->MAC

![网络包报文](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/网络包报文.jpg)

## 网卡

网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将数字信息转换为电信号，才能在网线上传输，也就是说，这才是真正的数据发送过程。

## 交换机

交换机的设计是将网络包原样转发到目的地。交换机工作在 MAC 层，也称为二层网络设备。

计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，交换机的端口不具有 MAC 地址。

将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。

交换机的 MAC 地址表主要包含两个信息：

- 一个是设备的 MAC 地址，
- 另一个是该设备连接在交换机的哪个端口上。

交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。

当 MAC 地址表找不到指定的 MAC 地址 或 接收方 MAC 地址是一个广播地址，那么交换机会将包发送到除源端口之外的所有端口。

## 路由器

路由器是基于 IP 设计的，俗称三层网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址

检查 MAC 头部中的接收方 MAC 地址，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。

总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。

MAC 头部的作用就是将包送达路由器，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会被丢弃。

接下来，路由器会根据 MAC 头部后方的 IP 头部中的内容进行包的转发操作。

转发操作分为几个阶段

- 查询路由表判断转发目标。根据包的接收方 IP 地址查询路由表中的目标地址栏，以找到相匹配的记录。实在找不到匹配路由时，就会选择默认路由。
- 根据路由表的网关列判断对方的地址
  - 如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，还未抵达终点，还需继续需要路由器转发。
  - 如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明已抵达终点。
- 通过 ARP 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。 路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求（在以太网中以广播的形式，对以太网所有的设备发出请求，对方发现ip是自己的后就会回复mac地址，如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址）。

网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。

发送出去的网络包会通过交换机到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。

接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。

路由器中还涉及到了 NAT:

- NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。
- 主要解决IPv4地址紧缺的问题，通过将一个公网IP地址和多个私网IP相对应，从而解决IP地址不够用的情况，但是这种技术仅起到了缓解的作用，真正解决还得靠IPv6来实现。
- 路由器将通过记录地址、应用程序端口等唯一标识一个转换。通过这种转换，可以使多个内部本地地址同时与同一个内部全局地址进行转换并对外部网络进行访问。

> 源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址，因为需要 MAC 地址在以太网内进行两个设备之间的包传输。

## 服务端与客户端

数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。

接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。

于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP 头部里面还有端口号， HTTP 的服务器正在监听这个端口号。

于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。

服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。

HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。

从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器。

最后跳到了客户端的路由器，路由器把包发给了交换机，再由交换机转发到客户端。

客户端收到了服务器的响应数据包后，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面。

最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。

