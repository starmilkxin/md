# HTTP
HTTP（Hypertext Transfer Protocol）超文本传输协议，是一种用于分布式、协作式和超媒体信息系统的应用层协议，可以说 HTTP 是当代互联网通信的基础。<br/>
但是HTTP是**明文传输**，因此它传输的消息会被**暴露**，甚至是被**篡改**。

![http明文](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/http明文.png)
<br/>
于是之后便诞生了HTTPS。所谓的HTTPS其实就是HTTP+SSL/TLS。

# SSL/TLS
## SSL/TLS发展历史
传输层安全性协议（英语：Transport Layer Security，缩写：TLS）及其前身安全套接层（英语：Secure Sockets Layer，缩写：SSL）的历史进程如下表所示：

![ssl/tls历史](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/20220318104522.png)

## TLS加密握手
TLS本身是一个混合加密系统，也就是说它使用了对称加密和非对称加密两种方式。利用非对称加密来传输双方商定的密钥，之后，再通过双方商定的密钥来进行对称加密。<br/>
因此TLS也可以理解为是一种协商密钥的方法。<br/>
<br/>
TLS1.2握手流程图如下

![TLS1.2流程图](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/20220318105214.png)

但是TLS发展到1.2以来，已经被很多机构和学者曝出有各种各样的安全漏洞，包括密钥交换算法（key exchange algorithms）、加密套件（ciphersuites）和数字签名（digital signatures）各个方面都存在安全问题，很多都是由于历史原因兼容问题而遗留下来的问题。<br/>
还有一些则是设计协议本身就存在的问题如TLS重新协议（renegotiation）可以让心怀不轨的人将高版本的TLS协议重新协商降级到低版本的不安全的协议然后进行攻击。又或者是SNI的不加密问题，TLS1.2及之前的协议都不对SNI进行加密，这也存在了很大的风险。<br/>
<br/>
于是TLS1.3诞生了。<br/>
针对TLSv1.2中存在的安全和性能问题，TLSv1.3在设计的时候就放弃了前向兼容性，不再对之前的版本进行兼容，同时禁用了大量不安全的算法，使用了少量安全的算法来设计协议，这样的好处就是可以简化握手过程中的操作，使得握手过程从2-RTT变为1-RTT，同时有效提高安全性和性能。<br/>
TLS1.3握手流程图如下

![tls1.3流程图](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/20220318105636.png)

TLS1.3中除去了Diffie-Hellman（DH）密钥交换以外的所有密钥交换算法。<br/>
我们来看DH算法交换密钥的步骤。假设客户端和服务器双方需要传递密钥，他们之间可以这么做：
1. 客户端首选选择一个素数p，例如509，底数g，任选，例如5，随机数a，例如123，然后计算A=g^a mod p，结果是215，然后，客户端发送p＝509，g=5，A=215给服务器；
2. 服务器收到后，也选择一个随机数b，例如，456，然后计算B=g^b mod p，结果是181，服务器再同时计算s=A^b mod p，结果是121；
3. 服务器把计算的B=181发给客户端，客户端计算s＝B^a mod p的余数，计算结果与服务器算出的结果一样，都是121。

所以最终双方协商出的密钥s是121。注意到这个密钥s并没有在网络上传输。而通过网络传输的p，g，A和B是无法推算出s的，因为实际算法选择的素数是非常大的。所以，更确切地说，DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输。

总结：
+ TLS的目的就是为了协商密钥，以供之后服务端与客户端通信传输数据使用。
+ TLS 1.2通过服务端的公钥，将客户端生成的密钥加密后，发送给服务端。服务端通过自己的私钥，解密得到密钥后，往后双方通过该密钥进行对称加密通信。
+ TLS 1.3通过一种特殊的算法，在一开始明文输出时，客户端发送给服务端参数，服务端再发送给客户端参数后，便可以生成可靠的密钥用以对称加密用。就算有中间人截获了两边发送的参数，也无法破解出密钥。

# HTTPS
HTTP采用明文传输，因此会遭受到中间人攻击

![http明文](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/http明文.png)

## 对称加密
采用一个双方共有拥有的密钥，对消息进行加密和解密，因此可以防范中间人攻击。

![对称加密](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/对称加密.png)

我们保证了数据的安全性，可是怎么保证数据的完整性呢？比如中间人虽然看不懂消息，但是对消息胡乱修改了一通，那么此时是不是就会令原接收方产生了误解呢？<br/>
答：使用数字签名，来保证数据的完整性，防止篡改。
+ 当双方协商好了共同密钥后，可以在发送数据时，同时发送数据的hash值H，这样就可以在解密后，对比数据计算得出的hash值和H是否相等，如果不是的话，那么就很有可能被篡改。
+ 通过非对称加密，利用私钥对数据的hash值进行

对称加密看起来非常不错，但问题是
+ 该密钥不能在网络中传输，否则被第三方知晓后还是会被中间人攻击。
+ 密钥如何让双方在私底下共同获取成为了问题。尤其是在需要与多个客户端进行通信时，更加地难以实现。

## 非对称加密
不同于对称加密只有一个密钥，它拥有一个私钥和一个公钥。
+ 公钥加密，私钥解密，可以保证数据的安全性，不会暴露给他人。
+ 私钥加密，公钥解密，则是可以保证数据的完整性，防止其被篡改。

![非对称加密1](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/非对称加密1.png)

我们发现，非对称加密不用像对称加密一样，需要私底下协商好唯一的密钥。它可以通过网络传播公钥，从而达到数据安全性。<br/>
但是如果只是单纯的非对称加密的话，每和一个客户端通信时，客户端都要生成自己的公钥和私钥，当有大量客户端时依旧是非常的消耗时间。<br/>
于是便产生了非对称加密+对称加密的方式。<br/>

## 非对称加密+对称加密

![非对称加密+对称加密](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/非对称加密+对称加密.png)

看起来是完美地解决了非对称加密导致的大量公钥、私钥问题。不过我们来想想，它能保证数据的完整性吗？
+ 对称加密的时候，数据的完整性可以得到保证，利用密钥对数据和hash进行加密，之后的接收方解密并对比一致性即可。
+ 客户端利用公钥A加密密钥后，发送给服务端时，此时的密钥如果被篡改该怎么办？答：不用担心，因为如果被篡改的话，此后客户端和服务端互相利用对称加密确认双方的时候，就会发生问题，从而发现密钥完整性的问题。
+ 第一步，发送公钥A时，如果公钥A被中间人篡改的话，该怎么办？这是一个大问题！如果我们想保证的公钥的完整性的话，那就需要同时发送其hash值，并对hash值进行加密操作，但显然这样就陷入了无限递归了(我们需要发送公钥实现整体的加密，但公钥的hash值又需要被加密)，无法做到，此时便需要CA登场！

## CA(数字证书认证机构)

![CA](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/CA.png)

第一步，服务端在发送公钥给客户端时，取而代之发送CA颁发的公钥证书。客户端通过公钥证书，以及内置在浏览器和操作系统中的CA公钥，便可以解密Hash值来判断是否被篡改。完美的保证了公钥的完整性、来源可靠性。<br/>
<br/>
**证书链**<br/>

![CA信任链](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/20220318151059.png)
![百度证书](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/20220318152215.png)

但事实上，证书的验证过程中还存在一个证书信任链的问题，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的。<br/>
对于这种三级层级关系的证书的验证过程如下：
+ 客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA256 - G2”，然后向 CA 请求该中间证书。
+ 请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 - G2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，如果发现验证通过，就认为该中间证书是可信的。
+ “GlobalSign Organization Validation CA - SHA256 - G2” 证书被信任后，可以使用 “GlobalSign Organization Validation CA - SHA256 - G2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。

最后一个问题，为什么需要证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？
+ 这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。

## HTTPS 建立连接完整过程

![https建立连接](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/https建立连接.jpg)

SSL/TLS 的「握手阶段」涉及四次通信:

1. ClientHello

首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。

在这一步，客户端主要向服务器发送以下信息：

（1）客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。

（2）客户端生产的随机数（Client Random），后面用于生产「会话秘钥」。

（3）客户端支持的密码套件列表，如 RSA 加密算法。

2. SeverHello

服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：

（1）确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。

（2）服务器生产的随机数（Server Random），后面用于生产「会话秘钥」。

（3）确认的密码套件列表，如 RSA 加密算法。

（4）服务器的数字证书。

3.客户端回应

客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。

如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：

（1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。

（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。

（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。

上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。

4. 服务器的最后回应

服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发生最后的信息：

（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。

（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

参考：
+ [SSL/TLS、对称加密和非对称加密和TLSv1.3](https://blog.csdn.net/qq_36885515/article/details/123137827)
+ [竟然是 300 万的诈骗案！](https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453152863&idx=1&sn=6b35ee1ec1e184fb3a312a0abab18fef&scene=21#wechat_redirect)
+ [HTTP2和HTTPS来不来了解一下？](https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484302&idx=1&sn=5fafcb988463b5b2df9120552b6dc3f8&chksm=ebd7428fdca0cb99d5ed60296100b315c4ecaefc901fb5bb5448f902c6f41b0fa0dc18d5ee06&scene=21#wechat_redirect)