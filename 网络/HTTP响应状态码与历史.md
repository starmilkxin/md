## HTTP响应状态码
以 2xx 为开头的都表示请求成功响应。

|状态码 |含义 |
|-- |-- |
|200 |成功响应 |
|204 |请求处理成功，但是没有资源可以返回 |
|206 |对资源某一部分进行响应，由Content-Range 指定范围的实体内容。 |

以 3xx 为开头的都表示需要进行附加操作以完成请求。

|状态码 |含义 |
|-- |-- |
|301 |永久性重定向，该状态码表示请求的资源已经重新分配 URI，以后应该使用资源现有的 URI|
|302 |临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。|
|303|该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。|
|304|该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。|
|307|临时重定向。该状态码与 302 Found 有着相同的含义。|
	
以 4xx 的响应结果表明客户端是发生错误的原因所在。

|状态码 |含义 |
|-- |-- |
|400 |该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。|
|401 |该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。|
|403|该状态码表明对请求资源的访问被服务器拒绝了。|
|404|该状态码表明服务器上无法找到请求的资源。|

以 5xx 为开头的响应标头都表示服务器本身发生错误。

|状态码 |含义 |
|-- |-- |
|500 |该状态码表明服务器端在执行请求时发生了错误。|
|503 |该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。|

## HTTP历史
### HTTP 1.0
特点
+ 1.0的HTTP版本，是一种无状态，无连接的应用层协议。 HTTP1.0规定浏览器和服务器保持短暂的链接。
+ 浏览器每次请求都需要与服务器建立一个TCP连接，服务器处理完成以后立即断开TCP连接(无连接)，服务器不跟踪也每个客户单，也不记录过去的请求(无状态)。
+ 这种无状态性可以借助cookie/session机制来做身份认证和状态记录。


存在的问题
+ 无法复用连接，每次发送请求，都需要进行一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率变低。
+ 队头阻塞(head of line blocking)，由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。
+ 不支持断点续传，也就是说，每次都会传送全部的页面和数据。

### HTTP 1.1
HTTP1.1继承了HTTP1.0的简单，克服了HTTP1.0性能上的问题。

特点
+ 长连接，HTTP1.1增加Connection字段，对于同一个host，通过设置Keep-Alive保持HTTP连接不断。避免每次客户端与服务器请求都要重复建立释放建立TCP连接。提高了网络的利用率。
如果客户端想关闭HTTP连接，可以在请求头中携带Connection:false来告知服务器关闭请求。
+ 支持断点续传，通过使用请求头中的 Range 来实现。
+ 可以使用管道传输，多个请求可以同时发送，但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是 前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」

### HTTP 2.0
特点
+ 二进制分帧，HTTP2.0通过在应用层和传输层之间增加一个二进制分层帧，突破了HTTP1.1的性能限制，改进传输性能。
+ 多路复用(链接共享)— 真并行传输流(stream)：已建立连接上的双向字节流；消息：与逻辑消息对应的完整的一系列数据帧；帧(frame)：HTTP2.0通信的最小单位，每个帧包含头部，至少也会标识出当前所属的流(stream_id)。所有HTTP2.0通信都在一个TCP链接上完成，这个链接可以承载任意流量的双向数据流。
每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符(Stream_id)重新封装。多路复用(连接共享)可能会导致关键字被阻塞，HTTP2.0里每个数据流都可以设置优先级和依赖，优先级高的数据流会被服务器优先处理和返回客户端，数据流还可以依赖其他的子数据流。可见，HTTP2.0实现了真正的并行传输，它能够在一个TCP上进行任意数量的HTTP请求。而这个强大的功能基于“二进制分帧”的特性。
+ 头部压缩，在HTTP1.X中，头部元数据都是以纯文本的形式发送的，通常会给每个请求增加500-8000字节的负荷。比如cookie，默认情况下，浏览器会在每次请求的时候，把cookie附在header上面发给服务器。
HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header_files表，既避免重复header的传输，又减少了需要传输的大小。
高效的压缩算法可以很大的压缩header，减少发送包的数量从而降低延迟。
+ 服务器推送，服务器除了最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确的需求

### HTTP 3.0
基于Google的QUIC，HTTP3 背后的主要思想是放弃 TCP，转而使用基于 UDP 的 QUIC 协议。与 HTTP2 在技术上允许未加密的通信不同，QUIC 严格要求加密后才能建立连接。此外，加密不仅适用于 HTTP 负载，还适用于流经连接的所有数据，从而避免了一大堆安全问题。建立持久连接、协商加密协议，甚至发送第一批数据都被合并到 QUIC 中的单个请求/响应周期中，从而大大减少了连接等待时间。如果客户端具有本地缓存的密码参数，则可以通过简化的握手（0-RTT）重新建立与已知主机的连接。

### 总结
HTTP 1.0
+ 无状态，无连接；
+ 短连接：每次发送请求都要重新建立tcp请求，即三次握手，非常浪费性能；
+ 无host头域，也就是http请求头里的host；不允许断点续传，而且不能只传输对象的一部分，要求传输整个对象。

HTTP 1.1
+ 长连接，流水线，使用connection:keep-alive使用长连接；
+ 请求管道化；
+ 增加缓存处理(新的字段如cache-control)；
+ 增加Host字段，支持断点传输等；
+ 由于长连接会给服务器造成压力。

HTTP 2.0
+ 二进制分帧；
+ 多路复用(或连接共享)，使用多个stream，每个stream又分帧传输，使得一个tcp连接能够处理多个http请求；
+ 头部压缩，双方各自维护一个header的索引表，使得不需要直接发送值，通过发送key缩减头部大小；
+ 服务器推送(Sever push)。

HTTP 3.0
+ 基于google的QUIC协议，而quic协议是使用udp实现的；
+ 减少了tcp三次握手时间，以及tls握手时间；
+ 解决了http 2.0中前一个stream丢包导致后一个stream被阻塞的问题；
+ 优化了重传策略，重传包和原包的编号不同，降低后续重传计算的消耗；
+ 连接迁移，不再用tcp四元组确定一个连接，而是用一个64位随机数来确定这个连接；
+ 更合适的流量控制。

原文链接：
+ https://blog.csdn.net/qq_36894974/article/details/103930478
+ http://events.jianshu.io/p/cd70b8e90d00