- [索引概念](#索引概念)
  - [索引优缺点](#索引优缺点)
  - [索引分类](#索引分类)
  - [索引适用与不适用条件](#索引适用与不适用条件)
- [索引优化](#索引优化)
- [执行计划](#执行计划)
- [索引下推](#索引下推)
- [索引失效](#索引失效)
  - [优化器选择全表扫描更快](#优化器选择全表扫描更快)
  - [覆盖索引可以防止索引失效导致的全表扫描](#覆盖索引可以防止索引失效导致的全表扫描)
  - [对索引使用函数/表达式计算](#对索引使用函数表达式计算)
  - [隐式类型转换](#隐式类型转换)
  - [非最左匹配(范围与模糊查询)](#非最左匹配范围与模糊查询)
  - [否定时索引失效](#否定时索引失效)
  - [OR前后不全是索引列](#or前后不全是索引列)

# 索引概念

## 索引优缺点

- 优点：
    1. 提高数据检索的效率，降低数据库的IO成本 ，这也是创建索引最主要的原因。 
    2. 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性 。 
    3. 在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时间 ，降低了CPU的消耗。
- 缺点：
    1. 创建索引和维护索引要耗费时间，并且随着数据量的增加，所耗费的时间也会增加。 
    2. 索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，存储在磁盘上，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。 
    3. 虽然索引大大提高了查询速度，同时却会降低更新表的速度 。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。

## 索引分类

按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。

按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。

按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。

按「字段个数」分类：单列索引、联合索引。

## 索引适用与不适用条件

什么时候适用索引？
- 字段有唯一性限制的，比如商品编码；
- 经常用于 WHERE 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。
- 经常用于 GROUP BY 和 ORDER BY 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。
  
什么时候不需要创建索引？
- WHERE 条件，GROUP BY，ORDER BY 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。
- 字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。
- 表数据太少的时候，不需要创建索引；
- 经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。

# 索引优化

前缀索引优化

- 减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。

覆盖索引优化

- query 的所有字段在二级索引叶子节点中都可以查找到，不需要通过聚簇索引查询获得，可以避免回表的操作。

主键索引最好自增

- 如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次插入一条新记录，都是追加操作，不需要重新移动数据，因此这种插入数据的方法效率非常高。
- 如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。

索引最好设置为 NOT NULL

- 索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。
- NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么行格式 (opens new window)中至少会用 1 字节空间存储 NULL 值列表。

防止索引失效

# 执行计划

对于执行计划，参数有：

- possible_keys 字段表示可能用到的索引；
- key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；
- key_len 表示索引的长度；
- rows 表示扫描的数据行数。
- filtered 。type=all，表示以全表扫描的方式得到1000条记录，且filtered=0.1%，表示只有1条记录是符合搜索条件的。此时如果加一个索引可以直接搜出来1条数据，那么filtered就可以提升到100%。
- type 表示数据扫描类型，重点。

type 字段就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的执行效率从低到高的顺序为：

- All（全表扫描）；
- index（全索引扫描）；额外：index merge 的意思就是对 两个索引列 分别进行了扫描，然后将这两个结果集进行了合并，这样做的好处就是避免了全表扫描。
- range（索引范围扫描）；
- ref（非唯一索引扫描）；
- eq_ref（唯一索引扫描）；
- const（结果只有一条的主键或唯一索引扫描）。

在这些情况里，all 是最坏的情况，因为采用了全表扫描的方式。index 和 all 差不多，只不过 index 对索引表进行全扫描，这样做的好处是不再需要对数据进行排序，但是开销依然很大。所以，要尽量避免全表扫描和全索引扫描。

range 表示采用了索引范围扫描，一般在 where 子句中使用 < 、>、in、between 等关键词，只检索给定范围的行，属于范围查找。从这一级别开始，索引的作用会越来越明显，因此我们需要尽量让 SQL 查询可以使用到 range 这一级别及以上的 type 访问方式。

ref 类型表示采用了非唯一索引，或者是唯一索引的非唯一性前缀，返回数据返回可能是多条。因为虽然使用了索引，但该索引列的值并不唯一，有重复。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描。

eq_ref 类型是使用主键或唯一索引时产生的访问方式，通常使用在多表联查中。比如，对两张表进行联查，关联条件是两张表的 user_id 相等，且 user_id 是唯一索引，那么使用 EXPLAIN 进行执行计划查看的时候，type 就会显示 eq_ref。

const 类型表示使用了主键或者唯一索引与常量值进行比较，比如 select name from product where id=1。

需要说明的是 const 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，const 是与常量进行比较，查询效率会更快，而 eq_ref 通常用于多表联查中。

extra:

- Using filesort：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。
- Using temporary：使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。
- Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。
- Using index condition：索引下推。

# 索引下推

对于联合索引（a, b），在执行 select * from table where a > 1 and b = 2 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？

在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。

而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

当你的查询语句的执行计划里，出现了 Extra 为 Using index condition，那么说明使用了索引下推的优化。

在二级索引表中，只要在找到叶子节点后，存在索引可以帮忙过滤结果，那么就可能会使用到 索引下推 (有时候查询优化器会选择全表扫描代替走索引)

> score_class为联合索引, score为int，class为varchar

联合索引score_class中，只使用到了score

```sql
EXPLAIN
select * from t
where score > 90; 
```

|type |possible_keys |key |key_len |ref |rows |filtered|extra |
|--- |--- |--- |--- |--- |--- |--- |--- |
|range |score_class |score_class |5 | |9 |100.00 |Using index condition |

联合索引score_class中，class 字段未作为索引使用，仅用作索引下推

```sql
EXPLAIN
select * from t
where score = 5 and class > 1; 
```

|type |possible_keys |key |key_len |ref |rows |filtered|extra |
|--- |--- |--- |--- |--- |--- |--- |--- |
|ref |class, score_class |score_class |5 |const |1 |33.33 |Using index condition |

联合索引score_class中，均使用(range 不一定性能比 ref 差，当 ref 的等值查询有多条相同记录时，range 可能比 ref 效果更好)

```sql
EXPLAIN
select * from t
where score = 5 and class > '1';
```
|type |possible_keys |key |key_len |ref |rows |filtered|extra |
|--- |--- |--- |--- |--- |--- |--- |--- |
|range |class, score_class |score_class |1028 | |1 |100.00 |Using index condition |


优化器采用全表扫描代替索引

```sql
EXPLAIN
select * from t
where score > 5; 
```

|type |possible_keys |key |key_len |ref |rows |filtered|extra |
|--- |--- |--- |--- |--- |--- |--- |--- |
|all |score_class | | | |18 |72.22 |Using where |



# 索引失效

## 优化器选择全表扫描更快

## 覆盖索引可以防止索引失效导致的全表扫描

## 对索引使用函数/表达式计算

同隐式类型转换，改变了索引导致索引失效。

## 隐式类型转换

条件为 int，索引类型为 varchar，导致索引从 varchar 转换为 int，导致索引失效。

条件为 varchar，索引类型为 int，导致条件从 varchar 转换为 int，索引未失效。

## 非最左匹配(范围与模糊查询)

创建了一个 (a, b, c) 联合索引。 a有序，b相对于a有序，c相对于a，b有序。

在B+树上，首先对比a的值向下走，当a寻找到指定的值后，对比b的值向下走，c同理，最终找到叶子节点。

where c=3 and a=1 and b=2; 查询优化器会调整字段位置(索引位置无法调整，B+树就是根据索引a，b，c建的)。

where a=1 and c=3; 联合索引

注：

对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。因为它们包含等值查询，联合索引的索引1用到了等值查询，那么对于等值查询的结果，索引2是相对有序的，所以依旧可以用到索引2。B+树在非叶子节点中找到了满足目标的临界节点，再通过索引2往下走。

在遇到范围查询（如 >、<、like非前缀）的时候，就会停止匹配。因为无法在非叶子节点中知道确切的临界点，必须要走到叶子节点后才能知道临界点，所以只能利用到索引1，而无法利用到索引2。

个人认为最左匹配原则的原理就是：

- 联合索引中，如果能根据索引1在非叶子节点中找到临界节点的话，那么索引2就能继续使用。
- 联合索引中，如果不能根据索引1在非叶子节点中找到临界节点，只能在叶子节点中找到的话，那么索引2就不能使用。

## 否定时索引失效

## OR前后不全是索引列

因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。