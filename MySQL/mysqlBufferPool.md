- [Buffer Pool](#buffer-pool)
  - [Buffer Pool 的意义](#buffer-pool-的意义)
  - [管理空闲页和脏页](#管理空闲页和脏页)
  - [脏页触发刷新](#脏页触发刷新)
  - [解决预读失效](#解决预读失效)
  - [解决 Buffer Pool 污染](#解决-buffer-pool-污染)

# Buffer Pool

## Buffer Pool 的意义

Innodb 存储引擎设计了一个缓冲池（Buffer Pool），来提高数据库的读写性能。

InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool  同样需要按「页」来划分。

有了缓冲池后：

- 当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取  Buffer Pool 中的数据，否则再去磁盘中读取。
- 当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘。

![bufferpool](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/bufferpool.png)

为了更好的管理这些在 Buffer Pool 中的缓存页，InnoDB 为每一个缓存页都创建了一个控制块，控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等等。

控制块也是占有内存空间的，它是放在 Buffer Pool 的最前面，接着才是缓存页。控制块和缓存页之间灰色部分称为碎片空间。

![bufferpool控制块](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/bufferpool控制块.png)

当我们查询一条记录时，InnoDB 是会把整个页的数据加载到 Buffer Pool 中，因为，通过索引只能定位到磁盘中的页，而不能定位到页中的一条记录。将页加载到 Buffer Pool 后，再通过页里的页目录去定位到某条具体的记录。

## 管理空闲页和脏页

空闲页

- 为了标记哪些页是空闲页，就使用了链表结构，将空闲缓存页的「控制块」作为链表的节点，一个一个串起来，这个链表称为 Free 链表（空闲链表）。
-有了 Free 链表后，每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free 链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从 Free 链表中移除。

脏页

- 为了能快速知道哪些缓存页是脏的，于是就设计出 Flush 链表，它跟 Free 链表类似的，链表的节点也是控制块，区别在于 Flush 链表的元素都是脏页。
- 有了 Flush 链表后，后台线程就可以遍历 Flush 链表，将脏页写入到磁盘。

## 脏页触发刷新

- 当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；
- Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；
- MySQL 认为空闲时，后台线程回定期将适量的脏页刷入到磁盘；
- MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；

## 解决预读失效

程序是有空间局部性的，靠近当前被访问数据的数据，在未来很大概率会被访问到。所以，MySQL 在加载数据页时，会提前把它相邻的数据页一并加载进来，目的是为了减少磁盘 IO。但是可能这些被提前加载进来的数据页，并没有被访问，相当于这个预读是白做了，这个就是预读失效。

不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是频繁访问的页，这样就大大降低了缓存命中率。

MySQL 改进了 LRU 算法，将 LRU 划分了 2 个区域：old 区域 和 young 区域。

old 区域占整个 LRU 链表长度的比例可以通过 innodb_old_blocks_pc 参数来设置，默认是 37，代表整个 LRU 链表中 young 区域与 old 区域比例是 63:37。

![bufferpool预读](https://cdn.jsdelivr.net/gh/starmilkxin/picturebed/img/bufferpool预读.png)

划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。

## 解决 Buffer Pool 污染

当某一个 SQL 语句扫描了大量的数据时，在  Buffer Pool 空间比较有限的情况下，可能会将 Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 Buffer Pool  污染。

不止大量的数据查询会导致 buffer pool 污染，如果索引失效就会导致全表扫描。

通过对进入到 young 区域条件增加了一个停留在 old 区域的时间判断，防止只因为被访问了一次而进入到 young 区域，从而导致热点数据被替换：

- 如果后续的访问时间与第一次访问的时间在某个时间间隔(innodb_old_blocks_time 参数默认1000 ms)内，那么该缓存页就不会被从 old 区域移动到 young 区域的头部。
- 如果后续的访问时间与第一次访问的时间不在某个时间间隔内，那么该缓存页移动到 young 区域的头部。
